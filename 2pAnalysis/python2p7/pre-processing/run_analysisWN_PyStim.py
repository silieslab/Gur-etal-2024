#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 10 15:58:17 2020

@author: burakgur
"""
#%% ROI selection and preprocessing of white noise stimulus generated by PyStim stimulation package (done on single T series)
# %% Importing packages
import os
import numpy as np
import matplotlib.pyplot as plt
import cPickle

os.chdir('/Volumes/Backup Plus/Post-Doc/_SiliesLab/Manuscripts/2023_Lum_Gain/Data_code/code/python2p7/pre-processing')
import analysis_core as aCore
import PyROI
plt.switch_backend('Qt5Agg') # Working with Visual Studio code, interactive plotting for ROI selection
plt.style.use('default')

# %% Setting the directories -> Change to your directories!!
initialDirectory = '/Volumes/HD-SP1/Burak_data/Python_data' # Main directory
alignedDataDir = os.path.join(initialDirectory, 'selected_experiments') # The directory where aligned dataset are located 
stimInputDir = os.path.join(initialDirectory, 'stimulus_types_cPP') # Need stimulus input files for extracting stimulus parameters
saveOutputDir = os.path.join(initialDirectory, 'analyzed_data/...') # Where to save the processed data 
summary_save_dir = os.path.join(alignedDataDir, '_summaries') # Summary plots for inspection
#%% Parameters
# Experimental parameters
current_exp_ID = '220125bg_fly2' # Folder
current_t_series ='TSeries-01252022-1014-007' #T series
Genotype = 'R64G09-Recomb-Homo' # Genotype
Age = '1-3' # Age range
Sex = 'f' # 'm' 'f'

# Analysis parameters
analysis_type = 'WN'

# ROI selection/extraction parameters 
extraction_type = 'manual' 
transfer_data_name = ''



#%% Get the stimulus and imaging information
current_movie_ID = current_exp_ID + '-' + current_t_series # A unique ID for this might will be useful
dataDir = os.path.join(alignedDataDir, current_exp_ID, current_t_series) 

(time_series, stim_info,imaging_info) = aCore.preProcessMovie(dataDir)

experiment_conditions = \
    {'Genotype' : Genotype, 'Age': Age, 'Sex' : Sex,
     'FlyID' : current_exp_ID, 'MovieID': current_movie_ID}

figure_save_dir = os.path.join(dataDir, 'Results')
if not os.path.exists(figure_save_dir):
    os.mkdir(figure_save_dir)
    

#%% Define analysis/extraction parameters and run region selection
#   generate ROI objects.

# Organizing extraction parameters
extraction_params = \
    aCore.organizeExtractionParams(extraction_type,
                               current_t_series=current_t_series,
                               current_exp_ID=current_exp_ID,
                               alignedDataDir=alignedDataDir,
                               use_other_series_roiExtraction = False,
                               use_avg_data_for_roi_extract = False,
                               roiExtraction_tseries=0,
                               transfer_data_n = transfer_data_name,
                               transfer_data_store_dir = saveOutputDir,
                               transfer_type = None,
                               imaging_info=imaging_info,
                               experiment_conditions=experiment_conditions)
        
    
analysis_params = {'deltaF_method': 'mean',
                   'analysis_type': analysis_type} 


#%% Select/extract ROIs
mean_image = time_series.mean(0)
(cat_masks, cat_names, roi_masks, all_rois_image, rois,
threshold_dict) = \
    aCore.selectROIs(extraction_params,image_to_select=mean_image)

# A mask needed in SIMA STICA to exclude ROIs based on regions
cat_bool = np.zeros(shape=np.shape(mean_image))
for idx, cat_name in enumerate(cat_names):
    if cat_name.lower() == 'bg':
        bg_mask = cat_masks[idx]
        continue
    elif cat_name.lower() =='otsu':
        otsu_mask = cat_masks[idx]
        continue
    cat_bool[cat_masks[cat_names.index(cat_name)]] = 1
    
# Generate ROI instances if not generated before
if rois == None:
    del rois
    rois = PyROI.generateROIs(roi_masks, cat_masks, cat_names, mean_image,
                                experiment_info = experiment_conditions, 
                                imaging_info =imaging_info)
else:
    # Add the source image - this will be used to plot the masks on top
    map(lambda roi: roi.setSourceImage(mean_image), rois)

# We can store the parameters inside the objects for further use
for roi in rois:
    roi.extraction_params = extraction_params
    roi.stim_info = stim_info 
    if extraction_type == 'transfer': # Update transferred ROIs
        roi.experiment_info = experiment_conditions
        roi.imaging_info = imaging_info
        for param in analysis_params.keys():
            roi.analysis_params[param] = analysis_params[param]
    else:
        roi.analysis_params= analysis_params


# %% 
# BG subtraction
time_series = np.transpose(np.subtract(np.transpose(time_series),
                                       time_series[:,bg_mask].mean(axis=1)))
print('\n Background subtraction done...')
# Stimulus 
stim = stim_info['meta']['epoch_infos']['epoch_2']['noise_texture']
# ROI raw signals
for iROI, roi in enumerate(rois):
    roi.raw_trace = time_series[:,roi.mask].mean(axis=1)
    roi.wn_stim = stim

#%% White noise analysis with 2D gaussian fitting
rois = PyROI.reverseCorrelation(rois,stim_up_rate=20)
final_rois = rois
for roi in final_rois:
    max_t = np.where(np.abs(roi.sta)==np.abs(roi.sta).max())[0][0]
    curr_sta = roi.sta[max_t,:,:]
    roi.max_t_sta = curr_sta
    roi.max_RF = curr_sta
    roi.RF_max_val = np.abs(roi.sta).max()
    roi.RF_quality = np.abs(roi.sta).max()/(roi.max_RF.mean()+(3*roi.max_RF.std()))

    # Fit Gaussian
    if np.abs(curr_sta).max() != curr_sta.max(): # Data should be transformed if the peak is negative
        data_to_fit = curr_sta*-1
    else:
        data_to_fit = curr_sta

    gauss_params, success, fit, r_squared = PyROI.fitTwoDgaussian(data_to_fit)

    (height, x, y, width_x, width_y) = gauss_params
    roi.rf_fit = fit
    roi.rf_fit_rsq = r_squared
    roi.rf_fit_params = gauss_params
    # center_coords = np.array(np.where(np.abs(curr_sta)==np.abs(curr_sta).max())).astype(float) # center as max
    center_coords = np.array([x,y]) # center as the center of the fitted gaussian

    wn_dim = roi.stim_info['meta']['epoch_infos']['epoch_2']['x_width']
    center_coords *= wn_dim # Find in degrees
    center_coords += wn_dim/2.0 # Find the center of the square

    # Transform array coordinates to screen coordinates in degrees
    # From fly perspective, up and right are minus coordinates (0 is center) 
    # but projection is flipped in X so in the array left and up are minus, 
    # right and down are plus

    center_coords[1] -= int(roi.stim_info['meta']['proj_params']['sizeX'])/2
    
    center_coords[0] = int(roi.stim_info['meta']['proj_params']['sizeX'])/2 - center_coords[0]
    center_coords[0] *= -1 
    roi.center_coords = center_coords

#%% Save plots
mask_image = PyROI.getMasksImage(final_rois)

aCore.plotAllMasks(mask_image, mean_image,len(final_rois),current_movie_ID,
    save_fig = True, save_dir = figure_save_dir)

PyROI.plotMasksROInums(final_rois,mean_image,save_fig = True, 
    save_dir = figure_save_dir,save_id = current_movie_ID)

# Plot and save the RF
PyROI.plotRFs_WN(final_rois, fig_save_dir=figure_save_dir,number = len(final_rois),
    f_w = 6)
# PyROI.plotRFs_WN(final_rois, fig_save_dir=figure_save_dir,number = len(final_rois),
#     f_w = 6,fit_plot=False)

#%% Save data
save_dict={'final_rois':final_rois}
save_name = os.path.join(saveOutputDir,'{ID}.pickle'.format(ID=current_movie_ID))
saveVar = open(save_name, "wb")
cPickle.dump(save_dict, saveVar, protocol=2) # Protocol 2 (and below) is compatible with Python 2.7 downstream analysis
saveVar.close()
print('\n\n%s saved...\n\n' % save_name)
    
    
    
    
    
    
    
    
    